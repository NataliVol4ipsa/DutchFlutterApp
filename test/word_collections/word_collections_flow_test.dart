/// Flutter has three test tiers:
///   • Unit tests  – pure Dart logic, no widgets, very fast.
///   • Widget tests – render widgets in a mock Flutter environment,
///                    no real device/emulator needed (this file).
///   • Integration tests – run against a real device/emulator with a real DB.
///
/// Widget tests give the best cost/value for UI flows:
///   - Fast (seconds, not minutes)
///   - No Isar/SQLite setup needed – the repository is replaced with a stub
///   - The real widget tree, routing and provider wiring is exercised
///
/// How to run:
///   flutter test test/word_collections/word_collections_flow_test.dart
///
/// IMPORTANT – before the first run you must generate the mock classes:
///   flutter pub run build_runner build --delete-conflicting-outputs
/// (or just `dart run build_runner build`)
library;
// ignore_for_file: avoid_relative_lib_imports

import 'package:dutch_app/core/local_db/repositories/word_collections_repository.dart';
import 'package:dutch_app/domain/models/word.dart';
import 'package:dutch_app/domain/models/word_collection.dart';
import 'package:dutch_app/domain/models/word_noun_details.dart';
import 'package:dutch_app/domain/notifiers/word_created_notifier.dart';
import 'package:dutch_app/domain/services/batch_word_operations_service.dart';
import 'package:dutch_app/domain/types/part_of_speech.dart';
import 'package:dutch_app/pages/home_page.dart';
import 'package:dutch_app/pages/quick_practice/quick_practice_coordinator.dart';
import 'package:dutch_app/pages/word_collections/word_collections_list_page.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:provider/provider.dart';

// Generated by: flutter pub run build_runner build --delete-conflicting-outputs
import 'word_collections_flow_test.mocks.dart';

// ── Helpers ────────────────────────────────────────────────────────────────

/// Builds a minimal [Word] suitable for testing.
Word _makeWord({
  int id = 1,
  String dutchWord = 'hond',
  List<String> englishWords = const ['dog'],
  PartOfSpeech partOfSpeech = PartOfSpeech.noun,
}) {
  return Word(
    id,
    dutchWord,
    englishWords,
    partOfSpeech,
    nounDetails: WordNounDetails(),
    verbDetails: null,
  );
}

/// Wraps the widget under test inside a [MaterialApp] that has all the
/// providers the pages need, plus the `/wordcollections` route.
Widget _buildTestApp({
  required MockWordCollectionsRepository collectionsRepo,
  required MockBatchWordOperationsService batchService,
  required MockQuickPracticeCoordinator coordinator,
}) {
  return MultiProvider(
    providers: [
      Provider<WordCollectionsRepository>.value(value: collectionsRepo),
      Provider<BatchWordOperationsService>.value(value: batchService),
      ChangeNotifierProvider<WordCreatedNotifier>(
        create: (_) => WordCreatedNotifier(),
      ),
      ChangeNotifierProvider<QuickPracticeCoordinator>.value(
        value: coordinator,
      ),
    ],
    child: MaterialApp(
      home: const HomePage(),
      routes: {
        '/wordcollections': (context) => const WordCollectionsListPage(),
        // The word-editor route is registered so that any NavBar taps that
        // happen to be rendered won't cause a missing-route crash.
        '/wordeditor': (context) => const Scaffold(),
      },
    ),
  );
}

// ── Tests ──────────────────────────────────────────────────────────────────

// Put the annotation on main() so build_runner can find it.
// Re-run `flutter pub run build_runner build` whenever this list changes.
@GenerateMocks([
  WordCollectionsRepository,
  BatchWordOperationsService,
  QuickPracticeCoordinator,
])
void main() {
  group('WordCollections – navigation & loading flow', () {
    late MockWordCollectionsRepository mockCollectionsRepo;
    late MockBatchWordOperationsService mockBatchService;
    late MockQuickPracticeCoordinator mockCoordinator;

    setUp(() {
      mockCollectionsRepo = MockWordCollectionsRepository();
      mockBatchService = MockBatchWordOperationsService();
      mockCoordinator = MockQuickPracticeCoordinator();

      // The HomePage bottom nav bar reads `coordinator.isLoading` during build.
      when(mockCoordinator.isLoading).thenReturn(false);
    });

    testWidgets('tapping Collections navigates to WordCollectionsListPage', (
      WidgetTester tester,
    ) async {
      when(
        mockCollectionsRepo.getCollectionsWithWordsAsync(),
      ).thenAnswer((_) async => [WordCollection(1, 'Animals')]);

      await tester.pumpWidget(
        _buildTestApp(
          collectionsRepo: mockCollectionsRepo,
          batchService: mockBatchService,
          coordinator: mockCoordinator,
        ),
      );

      await tester.tap(find.text('Collections'));
      await tester.pumpAndSettle();

      expect(find.byType(WordCollectionsListPage), findsOneWidget);
    });

    testWidgets(
      'collections page shows collection names returned by the repository',
      (WidgetTester tester) async {
        when(mockCollectionsRepo.getCollectionsWithWordsAsync()).thenAnswer(
          (_) async => [
            WordCollection(1, 'Animals'),
            WordCollection(2, 'Colors'),
          ],
        );

        await tester.pumpWidget(
          _buildTestApp(
            collectionsRepo: mockCollectionsRepo,
            batchService: mockBatchService,
            coordinator: mockCoordinator,
          ),
        );

        await tester.tap(find.text('Collections'));
        await tester.pumpAndSettle();

        expect(find.text('Animals'), findsOneWidget);
        expect(find.text('Colors'), findsOneWidget);
      },
    );

    testWidgets(
      'collections page shows the Dutch and English words belonging to a collection',
      (WidgetTester tester) async {
        final dog = _makeWord(dutchWord: 'hond', englishWords: ['dog']);
        final cat = _makeWord(id: 2, dutchWord: 'kat', englishWords: ['cat']);

        when(mockCollectionsRepo.getCollectionsWithWordsAsync()).thenAnswer(
          (_) async => [
            WordCollection(1, 'Animals', words: [dog, cat]),
          ],
        );

        await tester.pumpWidget(
          _buildTestApp(
            collectionsRepo: mockCollectionsRepo,
            batchService: mockBatchService,
            coordinator: mockCoordinator,
          ),
        );

        await tester.tap(find.text('Collections'));
        await tester.pumpAndSettle();

        // Collection header
        expect(find.text('Animals'), findsOneWidget);

        // Dutch words (rendered in SelectableWord widget)
        expect(find.text('hond'), findsOneWidget);
        expect(find.text('kat'), findsOneWidget);

        // English translations (joined by SemicolonWordsConverter)
        expect(find.text('dog'), findsOneWidget);
        expect(find.text('cat'), findsOneWidget);
      },
    );

    testWidgets('repository is called exactly once when the page loads', (
      WidgetTester tester,
    ) async {
      when(
        mockCollectionsRepo.getCollectionsWithWordsAsync(),
      ).thenAnswer((_) async => []);

      await tester.pumpWidget(
        _buildTestApp(
          collectionsRepo: mockCollectionsRepo,
          batchService: mockBatchService,
          coordinator: mockCoordinator,
        ),
      );

      await tester.tap(find.text('Collections'));
      await tester.pumpAndSettle();

      verify(mockCollectionsRepo.getCollectionsWithWordsAsync()).called(1);
    });
  });
}
